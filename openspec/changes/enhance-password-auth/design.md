# Design: 密码认证增强方案

## Context

当前系统已有基础的密码认证功能（后端完整实现），但前端入口被隐藏，且缺少必要的安全机制和用户体验优化。本次改进旨在：
- 在保持手机号+短信验证码为主要认证方式的前提下，完善密码登录作为备选方案
- 增强安全性（防暴力破解）
- 提升用户体验（浏览器自动填充、密码强度提示）

约束条件：
- 使用现有内存缓存，不引入Redis等新依赖
- 保持向后兼容，不影响现有手机号登录流程
- 遵循项目现有技术栈（Go + Gin, React + TypeScript, Zustand）

## Goals / Non-Goals

### Goals
- 提供完整可用的密码登录功能（前端+后端）
- 实现基于IP的登录失败追踪和临时黑名单
- 支持浏览器密码管理器自动填充
- 提供密码强度检查和用户反馈
- 支持注册时设置密码（可选）
- 保持手机号登录为主要入口，密码登录为辅助选项

### Non-Goals
- 不实现多因素认证（2FA/OTP），这属于另一个独立特性
- 不实现持久化黑名单（使用内存缓存，重启后清空）
- 不修改现有的JWT token机制
- 不引入新的外部依赖或服务
- 不实现账号永久锁定（仅临时锁定15分钟）

## Decisions

### 1. 登录失败黑名单机制

**决策**: 使用内存缓存 + IP地址作为黑名单标识

**理由**:
- 项目已使用内存缓存替代Redis，保持技术栈一致
- IP地址可以有效防止单一来源的暴力破解
- 临时锁定15分钟足以防御大多数自动化攻击
- 内存缓存重启清空，避免误伤正常用户

**策略**:
```
Key: "login_fail:{ip}"
Value: {
  count: int,          // 失败次数
  first_attempt: time, // 首次失败时间
  locked_until: time   // 锁定到期时间
}
TTL: 15分钟（自动过期）
```

**规则**:
- 5次失败触发锁定
- 锁定时长15分钟
- 锁定期间任何登录尝试直接拒绝并返回友好提示
- 成功登录后清除该IP的失败记录

**替代方案考虑**:
- 基于用户ID：不可行，因为攻击者可能尝试多个账号
- 基于Session：不适合RESTful API架构
- 永久黑名单：过于严格，维护成本高

### 2. 密码强度要求

**决策**: 最小6位，建议8位及以上，包含数字、字母

**理由**:
- 6位是当前后端最小限制，保持向后兼容
- 8位及以上推荐，符合行业标准
- 不强制特殊字符，避免用户体验过差
- 提供实时强度反馈而非硬性拒绝

**前端反馈策略**:
- 弱（6-7位，单一字符类型）：黄色警告
- 中（8-11位，两种字符类型）：蓝色提示
- 强（12位+，三种字符类型）：绿色鼓励

**后端验证**:
- 最小6位（硬性要求）
- 记录密码强度到日志（不记录明文）

### 3. Browser Autocomplete 支持

**决策**: 使用标准HTML5 autocomplete属性

**属性映射**:
| 场景 | 字段 | autocomplete值 |
|------|------|----------------|
| 登录 | 手机号 | `username` |
| 登录 | 密码 | `current-password` |
| 注册 | 手机号 | `username` |
| 注册 | 新密码 | `new-password` |
| 注册 | 确认密码 | `new-password` |
| 重置密码 | 新密码 | `new-password` |

**理由**:
- 符合W3C标准，兼容主流浏览器
- 手机号使用 `username` 而非 `tel`，便于密码管理器关联
- `current-password` vs `new-password` 帮助浏览器区分登录和注册场景

### 4. 前端登录方式切换

**决策**: 使用标签页（Tabs）切换，默认显示手机号登录

**布局方案**:
```
┌─────────────────────────────────────┐
│  [手机登录] | 密码登录               │  ← 标签切换
├─────────────────────────────────────┤
│                                     │
│  [当前选中的登录组件内容]            │
│                                     │
└─────────────────────────────────────┘
│        注册账号 | 忘记密码            │  ← 底部链接
└─────────────────────────────────────┘
```

**注册模式**:
- 注册页面独立，不使用标签切换
- 默认使用手机号+短信注册
- 可选填写密码（添加密码输入框，带确认）
- 未设置密码则使用默认密码"123456"（后端已有逻辑）

**理由**:
- 标签切换比下拉菜单更直观
- 手机登录默认显示，符合主要入口定位
- 注册流程简化，减少用户选择负担

### 5. 注册时密码处理

**决策**: 注册时密码为可选，未提供则使用默认密码

**流程**:
1. 用户填写手机号+短信验证码（必填）
2. 可选填写密码+确认密码
3. 后端逻辑：
   - 如果提供密码且验证通过，使用用户密码
   - 如果未提供密码，使用默认密码"123456"（当前逻辑）

**理由**:
- 降低注册门槛（手机号验证已足够）
- 支持高级用户自定义密码
- 向后兼容现有注册流程
- 用户后续可通过"修改密码"功能更新

**替代方案考虑**:
- 强制设置密码：增加注册摩擦，不符合快速注册理念
- 完全移除默认密码：破坏向后兼容性，影响现有用户

## Risks / Trade-offs

### 风险1: 基于IP的黑名单可能误伤共享IP用户

**场景**: 公司、学校等共享出口IP，一个用户多次失败可能影响其他用户

**缓解措施**:
- 锁定时长仅15分钟，影响有限
- 5次失败阈值较为宽松
- 提供清晰的错误提示，告知用户锁定时间
- 用户可选择使用手机号+短信登录绕过锁定

### 风险2: 内存缓存重启后丢失黑名单记录

**影响**: 服务器重启后攻击者可重新尝试

**缓解措施**:
- 记录登录失败到日志，便于监控
- 中小规模应用重启频率低，影响可控
- 如需持久化，后续可升级到Redis（不在本次范围）

### Trade-off: 密码强度要求宽松 vs 安全性

**决策**: 选择用户体验优先

**理由**:
- 最小6位已能防御大部分弱密码
- 配合黑名单机制可有效防御暴力破解
- 强度提示而非强制，避免用户流失
- 目标用户为简历优化（非银行级安全要求）

### Trade-off: 注册时密码可选 vs 一致性

**决策**: 保持可选，降低注册门槛

**理由**:
- 手机号验证已提供足够身份验证
- 符合"手机号为主，密码为辅"的产品定位
- 用户可后续随时设置/修改密码

## Migration Plan

### 阶段1: 后端改造（无破坏性）
1. 扩展内存缓存支持黑名单功能
2. 添加密码强度检查工具函数
3. 修改 `Login` 接口添加黑名单检查
4. 修改 `RegisterWithInvitation` 支持可选密码
5. 部署后端，现有功能不受影响

### 阶段2: 前端开发（并行开发）
1. 创建 `PasswordLogin` 组件
2. 修改 `PhoneLogin` 添加密码字段（注册模式）
3. 修改 `Auth` 页面添加标签切换
4. 添加 autocomplete 属性
5. 前端构建测试

### 阶段3: 联调测试
1. 测试密码登录流程
2. 测试黑名单机制
3. 测试浏览器自动填充
4. 测试注册带密码流程

### 阶段4: 部署上线
1. 前端构建并部署
2. 监控登录相关指标
3. 收集用户反馈

### 回滚方案
- 前端：注释掉密码登录入口（恢复当前状态）
- 后端：移除黑名单检查逻辑（登录功能本身已存在）
- 数据库：无需回滚（无schema变更）

## API 接口设计

详细的API接口规范请参考：**`api-spec.md`**

### 接口改动汇总

**修改的接口（2个）:**
1. `POST /api/user/login` - 添加IP黑名单检查
2. `POST /api/user/register` - 添加可选密码字段（password, confirm_password）

**新增服务层函数（3个）:**
1. `CheckLoginBlacklist(ip string) (bool, int)` - 检查IP是否被锁定
2. `RecordLoginFailure(ip string)` - 记录登录失败
3. `ClearLoginFailures(ip string)` - 清除失败记录

**改动位置:**
- `server/api/user/user.go` - Login和Register函数
- `server/service/user/user_service.go` - 添加3个新函数，修改RegisterWithInvitation签名
- `server/service/user/types.go` - RegisterRequest添加2个字段

### 关键设计决策

**黑名单Key设计:**
```
Key: "login_fail:{ip}"
Value: LoginFailInfo{Count, FirstAttempt, LockedUntil}
TTL: 15分钟
```

**密码字段处理:**
- Register接口：`password`和`confirm_password`均为可选
- 前端在API调用时验证一致性
- 后端再次验证并处理（双重验证）

## Open Questions

1. **是否需要记录登录失败日志到文件？**
   - 建议：是，便于监控异常IP和潜在攻击
   - 实现：在 `RecordLoginFailure` 中添加日志输出

2. **密码强度反馈是否需要后端接口？**
   - 建议：否，前端实时检查即可，减少请求
   - 后端仅在提交时验证最小长度

3. **是否需要"记住我"功能？**
   - 当前：不在本次范围
   - 后续：可考虑延长token有效期或使用refresh token

4. **黑名单锁定时是否需要通知管理员？**
   - 建议：频繁锁定的IP记录到日志，管理员可定期查看
   - 不实时通知，避免日志轰炸

